“原型是 JavaScript 中实现继承和属性共享的核心机制。每个对象都有一个内部链接（[[Prototype]]），指向另一个对象，称为它的原型对象。通过原型链，对象可以访问自身没有的属性或方法。

例如，构造函数有一个 prototype 属性，指向原型对象。当使用 new 关键字创建实例时，实例的 [[Prototype]] 指向构造函数的 prototype 对象。这样，所有实例共享原型对象中的属性和方法。

原型链的查找机制是，如果对象自身没有某个属性或方法，JavaScript 会沿着原型链向上查找，直到 Object.prototype 或 null。

在实际开发中，我们可以通过原型对象实现方法共享，动态修改原型对象，或者使用 ES6 类来更清晰地管理原型。”




每一个构造函数（自己写的构造函数 和内置的object的构造函数） 都有一个显示的原型属性：prototype
每一个对象实例 都有一个隐式的原型属性：_proto_ 
实例的_proto和对应函数的prototype都指向构造函数的原型对象

原型对象是存储这些共享属性和方法的具体对象

每一个构造函数 都有一个prototype的属性 这个属性一般被成为显式的原型属性   这个属性指向prototype 这个原型对象 
通过构造函数new的实例对象 也有一个属性 这个属性是__proto__ 这个属性 这个属性叫做隐式的原型属性
这个显式的原型属性 和隐式的原型属性 都指向同一个原型对象 就是prototype
这样两个属性 同一个指向 就可以打到一个目的
如果我为将共有的属性和方法 放在这个原型对象身上 那么我就可以 让每一个实例对象 都访问到这个方法

这就是原型对象

原型链本质 是一个已经定义好的查找机制
他的规则是
当我想要访问一个对象上的方法的时候，现在对象本身查找
如果对象本身有就执行
如果对象本身没有 就按照对象的隐式原型对象属性 所指向的地址 去查找
也就是对象的原型对象身上去查找
如果依旧找不到
那么因为原型对象本身也是一个对象 他也有自己的隐式原型属性
这个隐式的原型属性依旧指向一个原型对象 这个原型对象就是object的原型对象
这样我们就可以实现 创建一个对象的实例 虽然没有任何的方法 但是我们可以直接使用object身上的方法
如果说object上也没有 最后就会指向null 就是找不到  undefined

原型是对象继承属性和方法的机制（概念）


原型是js中实现对象继承属性和方法的机制，是一个概念
原型对象是实现这个机制的对象，原型对象上存在着共有的属性和方法
原型链就是一个查找机制
这个机制的规则就是
1、当我访问一个对象实例的方法的时候，会有限寻找这个对象身上的方法，如果有就执行，如果没有就会按照这个的隐式原型这个属性所指向的原型对象上去查找
2、如果可以在这个原型对象找到  就直接执行 找不到就继续查找
3、因为对象实例的隐式属性 所指向的原型对象 也是一个对象 所以这个原型对象也会有一个隐式原型这个属性 他指向了他的父构造函数的原型对象 ，然后就是依次向上查找 直到找到object的原型对象
4、这就解释了为什么在js中创建一个对象实例 可以直接使用object身上的方法；如果在object身上也没找到 会返回未定义
5、原型链的终点是object的原型对象 隐式原型这个属性 所指向的东西 他指向的是null

原型对象上 有constructor



给子元素实例的原型对象上  添加一属性
这样 子类的实例方法 可以通过隐式原型 这个属性  找到这个原型对象 并且拿到这个对象上的属性

现在的问题是 有个爹



我可以对woman这个原型对象上加方法
未来 再new woman（） 获得的实例对象 都可以获得这个实例方法
但是这样的修改 不会造成

